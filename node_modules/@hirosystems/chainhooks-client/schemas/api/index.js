"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.BulkEnableChainhooksResponseSchema = exports.BulkEnableChainhooksRequestSchema = exports.ApiStatusResponseSchema = exports.LimitParamSchema = exports.OffsetParamSchema = exports.EvaluateChainhookRequestSchema = exports.PaginatedChainhookResponseSchema = exports.ChainhookUuidParamSchema = exports.ConsumerSecretResponseSchema = exports.EnableChainhookRequestSchema = exports.UpdateChainhookRequestSchema = exports.RegisterChainhookRequestSchema = void 0;
const typebox_1 = require("@sinclair/typebox");
const chainhook_1 = require("../chainhook");
const utils_1 = require("../utils");
exports.RegisterChainhookRequestSchema = chainhook_1.ChainhookDefinitionSchema;
exports.UpdateChainhookRequestSchema = typebox_1.Type.Partial(chainhook_1.ChainhookDefinitionSchema);
exports.EnableChainhookRequestSchema = typebox_1.Type.Object({
    enabled: typebox_1.Type.Boolean({
        description: 'The enabled status of the chainhook',
    }),
});
exports.ConsumerSecretResponseSchema = typebox_1.Type.Object({
    secret: typebox_1.Type.Union([
        typebox_1.Type.String({
            format: 'hex',
            description: 'The current secret for the consumer',
        }),
        typebox_1.Type.Null({
            description: 'No consumer secret is currently configured',
        }),
    ], {
        description: 'Consumer secret value, null when no secret exists',
    }),
});
exports.ChainhookUuidParamSchema = typebox_1.Type.String({ format: 'uuid' });
exports.PaginatedChainhookResponseSchema = (0, utils_1.PaginatedResponse)(chainhook_1.ChainhookSchema, 'Paginated Chainhooks response');
exports.EvaluateChainhookRequestSchema = typebox_1.Type.Object({
    index_block_hash: typebox_1.Type.Optional(typebox_1.Type.String({
        minLength: 1,
        description: 'Stacks index block hash',
    })),
    block_height: typebox_1.Type.Optional(typebox_1.Type.Integer({ minimum: 0, description: 'Stacks block height' })),
}, { additionalProperties: false, minProperties: 1 });
exports.OffsetParamSchema = typebox_1.Type.Optional(typebox_1.Type.Integer({
    minimum: 0,
    title: 'Offset',
    description: 'Result offset',
}));
exports.LimitParamSchema = typebox_1.Type.Optional(typebox_1.Type.Integer({
    minimum: 1,
    maximum: 60,
    title: 'Limit',
    description: 'Results per page',
}));
exports.ApiStatusResponseSchema = typebox_1.Type.Object({
    server_version: typebox_1.Type.String(),
    status: typebox_1.Type.Literal('ready'),
});
const BulkEnableChainhooksFiltersSchema = typebox_1.Type.Object({
    uuids: typebox_1.Type.Optional(typebox_1.Type.Array(typebox_1.Type.String({ format: 'uuid' }), {
        minItems: 1,
        maxItems: 200,
        uniqueItems: true,
        description: 'Explicit chainhook UUIDs to enable or disable (maximum of 200 unique entries)',
    })),
    webhook_url: typebox_1.Type.Optional(typebox_1.Type.String({
        format: 'uri',
        description: 'Matches chainhooks registered with the given webhook URL',
    })),
    statuses: typebox_1.Type.Optional(typebox_1.Type.Array(chainhook_1.ChainhookStatusValueSchema, {
        minItems: 1,
        uniqueItems: true,
        description: 'Filters chainhooks whose current status matches any provided value',
    })),
}, { additionalProperties: false, minProperties: 1 });
exports.BulkEnableChainhooksRequestSchema = typebox_1.Type.Object({
    enabled: typebox_1.Type.Boolean({
        description: 'Enabled status to apply to the matching chainhooks',
    }),
    filters: typebox_1.Type.Optional(BulkEnableChainhooksFiltersSchema),
});
exports.BulkEnableChainhooksResponseSchema = typebox_1.Type.Object({
    updated_uuids: typebox_1.Type.Array(typebox_1.Type.String({ format: 'uuid' }), {
        description: 'UUIDs of chainhooks that were successfully enabled',
    }),
});
//# sourceMappingURL=index.js.map