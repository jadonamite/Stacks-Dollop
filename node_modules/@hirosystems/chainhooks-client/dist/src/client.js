"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChainhooksClient = exports.CHAINHOOKS_BASE_URL = void 0;
const undici_1 = require("undici");
const schemas_1 = require("./schemas");
/**
 * Network URLs for the Chainhooks Client
 */
exports.CHAINHOOKS_BASE_URL = {
    mainnet: 'https://api.mainnet.hiro.so',
    testnet: 'https://api.testnet.hiro.so',
};
/**
 * Chainhooks Client
 *
 * A TypeScript client for interacting with the Chainhooks API.
 */
class ChainhooksClient {
    config;
    requestHeaders;
    baseUrl;
    constructor(config) {
        this.config = config;
        this.requestHeaders = {
            Accept: 'application/json',
        };
        if (this.config.jwt) {
            this.requestHeaders['Authorization'] = `Bearer ${this.config.jwt}`;
        }
        if (this.config.apiKey) {
            this.requestHeaders['x-api-key'] = this.config.apiKey;
        }
        this.baseUrl = this.config.baseUrl;
    }
    /**
     * Register a new chainhook
     */
    async registerChainhook(definition) {
        return this.request({
            method: 'POST',
            path: '/chainhooks/me',
            body: JSON.stringify(definition),
        });
    }
    /**
     * Update a chainhook by UUID
     */
    async updateChainhook(uuid, definition) {
        return this.request({
            method: 'PATCH',
            path: `/chainhooks/me/${uuid}`,
            body: JSON.stringify(definition),
        });
    }
    /**
     * Get all chainhooks with pagination
     */
    async getChainhooks(options = {}) {
        const query = {};
        if (options.offset !== undefined) {
            query.offset = options.offset.toString();
        }
        if (options.limit !== undefined) {
            query.limit = options.limit.toString();
        }
        return this.request({
            method: 'GET',
            path: '/chainhooks/me',
            query,
        });
    }
    /**
     * Get a specific chainhook by UUID
     */
    async getChainhook(uuid) {
        return this.request({
            method: 'GET',
            path: `/chainhooks/me/${uuid}`,
        });
    }
    /**
     * Change the enabled status of a chainhook by UUID
     */
    async enableChainhook(uuid, enabled) {
        await this.request({
            method: 'PATCH',
            path: `/chainhooks/me/${uuid}/enabled`,
            body: JSON.stringify({ enabled }),
        });
    }
    /**
     * Update the enabled status of multiple chainhooks using filters
     */
    async bulkEnableChainhooks(requestBody) {
        if (typeof requestBody.enabled !== 'boolean') {
            throw new Error('Enabled flag must be provided');
        }
        const filters = requestBody.filters;
        if (!filters ||
            (!filters.uuids && !filters.webhook_url && !filters.statuses)) {
            throw new Error('At least one filter must be provided');
        }
        return this.request({
            method: 'PATCH',
            path: '/chainhooks/me/enabled',
            body: JSON.stringify(requestBody),
        });
    }
    /**
     * Delete a chainhook by UUID
     */
    async deleteChainhook(uuid) {
        await this.request({
            method: 'DELETE',
            path: `/chainhooks/me/${uuid}`,
        });
    }
    /**
     * Generate or rotate a consumer secret
     */
    async rotateConsumerSecret() {
        return this.request({
            method: 'POST',
            path: `/chainhooks/me/secret`,
        });
    }
    /**
     * Retrieve the current consumer secret (null when none is configured)
     */
    async getConsumerSecret() {
        return this.request({
            method: 'GET',
            path: `/chainhooks/me/secret`,
        });
    }
    /**
     * Delete a consumer secret
     */
    async deleteConsumerSecret() {
        return this.request({
            method: 'DELETE',
            path: `/chainhooks/me/secret`,
        });
    }
    /**
     * Queue an on-demand evaluation for a chainhook
     */
    async evaluateChainhook(uuid, requestBody) {
        await this.request({
            method: 'POST',
            path: `/chainhooks/me/${uuid}/evaluate`,
            body: JSON.stringify(requestBody),
        });
    }
    /**
     * Get API status
     */
    async getStatus() {
        return this.request({
            method: 'GET',
            path: '/chainhooks',
        });
    }
    async request(options) {
        const { method, path, body, query } = options;
        const url = new URL(path, this.baseUrl);
        if (query) {
            Object.entries(query).forEach(([key, value]) => {
                url.searchParams.append(key, value.toString());
            });
        }
        const headers = { ...this.requestHeaders };
        if (body) {
            headers['Content-Type'] = 'application/json';
        }
        const { statusCode, headers: resHeaders, body: responseBody, } = await (0, undici_1.request)(url.toString(), {
            method,
            headers,
            body,
        });
        if (statusCode === 204) {
            return null;
        }
        if (statusCode >= 200 && statusCode < 300) {
            const data = await responseBody.json();
            return data;
        }
        const bodyText = await responseBody.text();
        let parsed;
        // Try to parse JSON, otherwise just fall back to dumping the text
        try {
            parsed = JSON.parse(bodyText);
        }
        catch {
            parsed = bodyText;
        }
        const normalizedHeaders = {};
        for (const [k, v] of Object.entries(resHeaders)) {
            if (v == null)
                continue;
            normalizedHeaders[k] = Array.isArray(v) ? v : String(v);
        }
        throw new schemas_1.ChainhooksHttpError(statusCode, url.toString(), method, normalizedHeaders, bodyText, parsed);
    }
}
exports.ChainhooksClient = ChainhooksClient;
//# sourceMappingURL=client.js.map